<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pwncollege - embryoio</title>
    <link href="/2022/06/15/pwncollege%20-%20embryoio/"/>
    <url>/2022/06/15/pwncollege%20-%20embryoio/</url>
    
    <content type="html"><![CDATA[<p>前些日子在某知识星球了解到了pwn.college，ASU CSE466的课程网站。站内module简单且较成体系，希望刷完能有所得。第一章，emryoio从 5&#x2F;15 断断续续做到 6&#x2F;15 终于把142道都做完了。鉴于网站规则，不能上传具体的题解，主要记录一下知识点。</p><span id="more"></span><h1 id="level1-7-Basic"><a href="#level1-7-Basic" class="headerlink" title="level1-7 Basic"></a>level1-7 Basic</h1><p>直接运行文件 </p><hr><p>传参直接在文件名后接参数</p><hr><p><code>export</code> 设置环境变量</p><hr><p>重定向输入（&gt;）与输出 ( &lt; )</p><hr><p><code>env -i</code> + 运行文件 忽略环境变量运行程序</p><h1 id="level8-14-shell脚本"><a href="#level8-14-shell脚本" class="headerlink" title="level8-14 shell脚本"></a>level8-14 shell脚本</h1><p>编写shell脚本 </p><p>（<code>env -i</code> ）&#x2F; challenge&#x2F;embryoio_level + 参数 （+ redirect ）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>exec -c /challenge/embryo* #直接将运行脚本的进程替换为运行challenge的进程 运行时的parent是shell脚本之上的interactive shell<br>env -i /challenge/embryo <br>bash -c &quot;exec -c /challenge/embryo&quot;# 在sub shell运行“”内的指令<br>(<br>exec -c /challenge/embryo*<br>) #在sub shell运行“”内的指令<br> <br></code></pre></td></tr></table></figure><h1 id="level15-21-ipython"><a href="#level15-21-ipython" class="headerlink" title="level15-21 ipython"></a>level15-21 ipython</h1><p><strong>ipython</strong> 直接执行shell命令 “ ！+指令” （<strong>该情况python launch 一个shell用来launch process</strong>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br>p=subprocess.Popen([<span class="hljs-string">&quot;/challenge/embryoio_level&quot;</span>], stdout=subprocess.PIPE.stdin=subprocess.PIPE)<br>p.stdout.read()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pwn<br>p=pwn.process([<span class="hljs-string">&quot;/challenge/embryoio_level&quot;</span>] + [参数], env=&#123;<span class="hljs-string">&quot;环境变名&quot;</span>:<span class="hljs-string">&quot;值&quot;</span>&#125;, stdout=pwn.PIPE.stdin=pwn.PIPE)<br><span class="hljs-built_in">print</span> (p.read().decode())<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob <br>glob.glob(<span class="hljs-string">&quot;....&quot;</span>)<span class="hljs-comment">#需要一个参数用来指定匹配的路径字符串，其返回文件名只包括当前目录里的文件名。</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;filename&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>)<span class="hljs-keyword">as</span> x:<br>    x.write(<span class="hljs-string">&quot;asdf&quot;</span>)<br>p=pwn.process([<span class="hljs-string">&quot;/challenge/embryoio_level&quot;</span>], stdout=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;filename&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>),stdin=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;fliename&quot;</span>))<br><span class="hljs-comment">#  redirect</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># os也能够对环境变量进行操作</span><br><span class="hljs-keyword">import</span> os<br>os.environ[<span class="hljs-string">&#x27;name&#x27;</span>]=<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-comment">#设置环境变量</span><br>os.environ.get(<span class="hljs-string">&#x27;name&#x27;</span>) <span class="hljs-comment">#获取环境变量</span><br>os.getenv(<span class="hljs-string">&#x27;path&#x27;</span>) <span class="hljs-comment">#获取环境变量</span><br><span class="hljs-keyword">del</span> os.environ[<span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure><h1 id="level22-28-python脚本"><a href="#level22-28-python脚本" class="headerlink" title="level22-28 python脚本"></a>level22-28 python脚本</h1><p>同Ipython</p><p><strong>level27</strong> 遇到 redirect 指定file 到stdout，文件未被写入的问题。通过查阅pwntools文档，使用**wait_for_close()**。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>wait_for_close(timeout=pwnlib.timeout.Timeout.default)<br>wait(timeout=pwnlib.timeout.Timeout.default)<br><span class="hljs-comment"># Waits until the tube is closed.</span><br><span class="hljs-comment"># Python会先将数据临时存储到缓冲区中，只有使用 close() 函数关闭文件时，才会将缓冲区中的数据真正写入文件中。</span><br></code></pre></td></tr></table></figure><h1 id="level29-35-C脚本"><a href="#level29-35-C脚本" class="headerlink" title="level29-35 C脚本"></a>level29-35 C脚本</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">char</span> *参数[]=&#123;<span class="hljs-string">&quot;fliename&quot;</span>,参数<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>&#125;<br>    <span class="hljs-type">char</span> *环境[]=&#123;<span class="hljs-string">&quot;环境变量=值&quot;</span>,<span class="hljs-literal">NULL</span>&#125;<br>    <span class="hljs-type">int</span> i = fork();<span class="hljs-comment">//fork creates a new child</span><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<span class="hljs-comment">//execv replace the current process</span><br>    &#123;<br>        execve(argv[<span class="hljs-number">1</span>],<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//execl  </span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        waitpid(i, <span class="hljs-literal">NULL</span> , <span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main函数的参数"><a href="#main函数的参数" class="headerlink" title="main函数的参数"></a>main函数的参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span>=<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>    1. <span class="hljs-type">int</span> <span class="hljs-title function_">argc</span> <span class="hljs-params">(arguments count 参数计数)</span><br> 运行程序传送给main函数的命令行参数总个数，包括可执行文件的文件名，存储在argv[0]中<br>    2. <span class="hljs-type">char</span> **<span class="hljs-title function_">argv</span> <span class="hljs-params">(arguments value/<span class="hljs-built_in">vector</span> 参数值)</span><br> argv[0]指向程序运行时的全路径名<br> argv[1]指向程序在DOS命令中执行程序名后的第一个字符串<br> argv[2]指向第二个字符串<br> argc[argc] 为<span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>fork执行后有两次返回</p><ol><li>在父进程中，fork返回新创建子进程的进程ID；</li><li>在子进程中，fork返回0；</li><li>如果出现错误，fork返回一个负值；</li></ol><h2 id="execve函数"><a href="#execve函数" class="headerlink" title="execve函数"></a>execve函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ..., <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><span class="hljs-comment">//执行成功无返回；出错返回-1</span><br></code></pre></td></tr></table></figure><h2 id="wait-x2F-waitpid"><a href="#wait-x2F-waitpid" class="headerlink" title="wait &#x2F; waitpid"></a>wait &#x2F; waitpid</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">include &lt;sys/wait.h&gt;<br>waitpid(<span class="hljs-type">pid_t</span> pid ,<span class="hljs-type">int</span> *status ,<span class="hljs-type">int</span> options);<br>wait(<span class="hljs-type">int</span> *status);<br></code></pre></td></tr></table></figure><p>第一个参数为指定的子进程识别码，第二个参数用以了解子进程为什么会退出（不需要则为NULL），第三个为控制waitpid()的函数行为</p><p>当一个parent创建了一个child但没有等它结束就自己结束的话就可能造成系统异常，使用waitpid()来等待孩子进程。</p><table><thead><tr><th align="center">pid值</th><th align="center">waitpid()的操作</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">等待任一子进程</td></tr><tr><td align="center">&gt;0</td><td align="center">等待其进程ID与pid相等的子进程</td></tr><tr><td align="center">&#x3D;&#x3D;0</td><td align="center">等待其组ID等于调用进程组ID的任一的子进程</td></tr><tr><td align="center">&lt;-1</td><td align="center">等待其组ID等于pid绝对值的任一子进程</td></tr></tbody></table><p><strong>wait函数为waitpid函数的简化版,wait返回任一终止状态的子进程，waitpid等待指定进程</strong></p><h2 id="open-x2F-close"><a href="#open-x2F-close" class="headerlink" title="open &#x2F; close"></a>open &#x2F; close</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>    #<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span>    #<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname ,<span class="hljs-type">int</span> flags)</span>;<br>打开文件成功返回文件描述符（未使用的且为最小的fd）<br>打开文件失败返回 <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><ul><li><p><code>flags</code>：用来控制打开文件的模式</p><ul><li><code>O_RDONLY</code>：只读模式</li><li><code>O_WRONLY</code>：只写模式</li><li><code>O_RDWR</code>：可读可写</li><li>……</li></ul></li><li><p><code>mode</code>：用来设置创建文件的权限（rwx）。当flags中带有<code>O_CREAT</code>时才有效。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>返回值为0则关闭文件成功<br>返回值为-1则代表失败<br></code></pre></td></tr></table></figure><h3 id="文件描述符（file-descriptor）"><a href="#文件描述符（file-descriptor）" class="headerlink" title="文件描述符（file descriptor）"></a>文件描述符（<em>file descriptor</em>）</h3><ul><li><p>进程级 <strong>文件描述符表(file descriptor table)</strong></p><p>一般情况下，每个 Unix&#x2F;Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul></li><li><p>系统级 <strong>打开文件表(open file table)</strong></p></li><li><p>文件系统 <strong>i-node表( i-node table)</strong></p></li></ul><p><img src="/img/fd.png"></p><h2 id="dup和dup2"><a href="#dup和dup2" class="headerlink" title="dup和dup2"></a>dup和dup2</h2><p><code>dup()</code>或者<code>dup2()</code>主要是将某个特定的文件描述字输出输出的重定向<br>他们保证将复制的文件描述字到当前未打开的最小描述字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span><br>    参数oldfd表示需要复制的文件（必须已打开）的文件描述符<br>    返回值：若成功复制则返回一个新的文件描述符；若失败则返回-1<br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<br></code></pre></td></tr></table></figure><p><strong>二者区别</strong></p><p>调用<code>dup(oldfd)</code>等效于，<code>fcntl(oldfd, F_DUPFD, 0)</code><br>调用<code>dup2(oldfd, newfd)</code>等效于，<code>close(oldfd)；fcntl(oldfd, F_DUPFD, newfd)；</code></p><h3 id="重定向输入输出"><a href="#重定向输入输出" class="headerlink" title="重定向输入输出"></a>重定向输入输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> *oldfile ,STDIN_FILENO)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> *oldfile ,STDOUT_FILENO)</span><br></code></pre></td></tr></table></figure><p><strong>STDIN_FILENO 是标准输入的文件描述符</strong></p><h2 id="c脚本重定向输入"><a href="#c脚本重定向输入" class="headerlink" title="c脚本重定向输入"></a>c脚本重定向输入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//方法1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>FILE *<span class="hljs-title function_">freopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode, FILE *stream)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//方法2</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>   FILE *fp;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该文本重定向到 stdout\n&quot;</span>);<br>   fp = freopen(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>, <span class="hljs-built_in">stdout</span>);<span class="hljs-comment">//创建一个用于读写的新文件</span><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该文本重定向到 file.txt\n&quot;</span>);<br>   fclose(fp);<br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="level36-65-PIPES"><a href="#level36-65-PIPES" class="headerlink" title="level36-65 PIPES"></a>level36-65 PIPES</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typora">A pipe is a  form of redirection (transfer of standard output to some other destination)<br><br> allow stdout of a command to be connected to stdin of another command<br><br>pipe character &#x27; | &#x27;<br><br>Pipe is used to combine two or more commands, and in this, the output of one command acts as input to another command, and this command’s output may act as input to the next command and so on. <br><br>Syntax:<br>command_1 | command_2 | command_3 | .... | command_N <br></code></pre></td></tr></table></figure><p>**send EOF &#x3D; ctrl + D  ：close the program **</p><h2 id="python脚本的pipes"><a href="#python脚本的pipes" class="headerlink" title="python脚本的pipes"></a>python脚本的pipes</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br>pwn.context.log_level = <span class="hljs-string">&quot;DEBUG&quot;</span><br>p2= pwn.process([<span class="hljs-string">&quot;sed&quot;</span>, <span class="hljs-string">&quot;-e&quot;</span>, <span class="hljs-string">&quot;s/X/X/&quot;</span>], stdin=pwn.PIPE)<br>p1= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=p2.stdin)<br><span class="hljs-built_in">print</span>(p2.readall())<br></code></pre></td></tr></table></figure><h3 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a>subprocess</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br>p1 = subprocess.Popen([<span class="hljs-string">&quot;/challenge/embryoio_level&quot;</span>], stdout=subprocess.PIPE)<br>p2 = subprocess.Popen([<span class="hljs-string">&quot;cat&quot;</span>], stdin=p1.stdout, stdout=subprocess.PIPE)<br><span class="hljs-built_in">print</span>(p2.communicate()[<span class="hljs-number">0</span>].decode())<br></code></pre></td></tr></table></figure><h3 id="level52"><a href="#level52" class="headerlink" title="level52"></a>level52</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">14</span>]: <span class="hljs-keyword">import</span> pwn<br><span class="hljs-comment">#使用cat传入password</span><br><span class="hljs-comment">#或者使用sendline进行传递</span><br></code></pre></td></tr></table></figure><h3 id="level59"><a href="#level59" class="headerlink" title="level59"></a>level59</h3><p>这题使用subprocess时碰到了一些问题，主要是<code>Popen.communicate()</code>的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Popen.communicate(<span class="hljs-built_in">input</span>=<span class="hljs-literal">None</span>, timeout=<span class="hljs-literal">None</span>)<br><span class="hljs-comment">#与进程交互：将数据发送到 stdin。 从 stdout 和 stderr 读取数据，直到抵达文件结尾。</span><br><span class="hljs-comment">#本题中，若不加入communicate()函数，/challenge的parent变为docker-init</span><br><span class="hljs-comment">#原因为/challenge的parent已经结束，进而发生继承</span><br><span class="hljs-comment">#猜测原因，不使用communicate()，rev不会等待子进程，直接terminates</span><br></code></pre></td></tr></table></figure><h1 id="C脚本的PIPEs"><a href="#C脚本的PIPEs" class="headerlink" title="C脚本的PIPEs"></a>C脚本的PIPEs</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">( <span class="hljs-type">int</span> pipe_fds[<span class="hljs-number">2</span>] )</span>  <br><span class="hljs-comment">//return 成功返回0，否则返回-1。参数数组包含pipe是用的两个文件的描述符。</span><br><span class="hljs-comment">//fd[0]为read管道 fd[1]为write管道</span><br><span class="hljs-comment">//必须在fork中调用pipe()否则子进程不会继承文件描述符。两个进程不共享parent进程就不能使用pipe。</span><br></code></pre></td></tr></table></figure><p>c pipes具体实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">int</span> pid=fork();<br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        &#123;<br>                <span class="hljs-type">int</span> pipe_fd[<span class="hljs-number">2</span>];<br>                pipe(pipe_fd);<br>                <span class="hljs-type">int</span> i =fork();<br>                <span class="hljs-keyword">if</span> (i!=<span class="hljs-number">0</span>)<br>                &#123;<br>                        dup2(pipe_fd[<span class="hljs-number">1</span>],<span class="hljs-number">1</span>);<br>                        execve(<span class="hljs-string">&quot;/challenge/embryoio_level&quot;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        dup2(pipe_fd[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>);<br>                        execl(<span class="hljs-string">&quot;/bin/cat&quot;</span>,<span class="hljs-string">&quot;/bin/cat&quot;</span>,<span class="hljs-literal">NULL</span>);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                waitpid(pid,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="level61-68-find指令"><a href="#level61-68-find指令" class="headerlink" title="level61-68 find指令"></a>level61-68 find指令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /challenge/ -name embryoio_level66 -exec &#123;&#125; ;<br></code></pre></td></tr></table></figure><h1 id="level68-73-shell脚本杂项"><a href="#level68-73-shell脚本杂项" class="headerlink" title="level68-73 shell脚本杂项"></a>level68-73 shell脚本杂项</h1><p><strong>使用c进行辅助更方便些</strong></p><h1 id="level74-79-python脚本杂项"><a href="#level74-79-python脚本杂项" class="headerlink" title="level74-79 python脚本杂项"></a>level74-79 python脚本杂项</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(argv = [], executable = <span class="hljs-string">&quot;/challenge/embryoio_level75&quot;</span>)<br>p.interactive() <span class="hljs-comment">#设置参数为空</span><br></code></pre></td></tr></table></figure><h1 id="level80-85-c脚本杂项"><a href="#level80-85-c脚本杂项" class="headerlink" title="level80-85 c脚本杂项"></a>level80-85 c脚本杂项</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#inlcude <span class="hljs-string">&lt;unistd.h&gt;</span></span><br>chdir(path);<br><span class="hljs-comment">//change the current working directory</span><br></code></pre></td></tr></table></figure><h1 id="level86-98-shell脚本杂项2"><a href="#level86-98-shell脚本杂项2" class="headerlink" title="level86-98 shell脚本杂项2"></a>level86-98 shell脚本杂项2</h1><h2 id="level86-87-interaction"><a href="#level86-87-interaction" class="headerlink" title="level86-87 interaction"></a>level86-87 interaction</h2><p>写了个脚本自动交互，恰好后面也用的上</p><h2 id="level88-89-argv-0"><a href="#level88-89-argv-0" class="headerlink" title="level88-89 argv[0]"></a>level88-89 argv[0]</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">argv[0] is passed into the execve() system call *separately* from the program path to execute.This means that it does not have to be the same as the program path, and that you can actually control it. This is done differently for different methods of execution. For example, in C, you simply need to pass in a different argv[0]. Bash has several ways to do it, but one way is to use a combination of a symbolic link (e.g., the `ln -s` command) and the PATH environment variable.<br></code></pre></td></tr></table></figure><p><strong>设定PATH环境变量</strong></p><p><code>$PATH</code>：输入命令时，系统通过查找PATH中的路径来执行具体文件。各个目录用<code>:</code>分割开</p><p><strong>command</strong></p><ul><li>which – 查找各个外部指令所在的绝对路径</li><li>export – 修改环境变量（临时）</li></ul><h2 id="level90-93-FIFO"><a href="#level90-93-FIFO" class="headerlink" title="level90-93 FIFO"></a>level90-93 FIFO</h2><p><strong>FIFO - named pipe</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typora">有名管道 FIFO 和无名管道 Pipe 主要的区别就是 FIFO 在磁盘上建立管道文件（FIFO 将内核数据缓冲区映射到了实际的文件节点），所以我们可以在磁盘上实际看到，故称为「有名字」，而 Pipe 没有在磁盘上建立文件，我们不能实际看到，故称为「无名」<br>我们使用 FIFO 是在磁盘上建立一个管道文件，然后利用这个文件作为管道的传输通道，但是这个管道文件很特殊，它的大小始终为 0，原因是管道的数据是存放在内核的内存中的，不在管道文件中，我们也可以验证这个事实。<br></code></pre></td></tr></table></figure><p>向管道写数据必须用<code>&gt;</code>，从管道读数据时必须用<code>&lt;</code>。还有一点是写管道的时候必须要用<code>&amp;</code>把进程挂到后台 &#x2F; 或者在两个终端进行交互</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfifo fifo_flie<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><h2 id="level94-exec重定向"><a href="#level94-exec重定向" class="headerlink" title="level94 exec重定向"></a>level94 exec重定向</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exec fd_num &lt; filename #打开文件作为当前shell的输入，并分配文件描述符<br></code></pre></td></tr></table></figure><h2 id="level97-98-信号"><a href="#level97-98-信号" class="headerlink" title="level97-98 信号"></a>level97-98 信号</h2><p>使用<code>kill -signum pid</code>可以发送指定的信号给指定的进程。</p><h1 id="level99-111-python杂项2"><a href="#level99-111-python杂项2" class="headerlink" title="level99-111 python杂项2"></a>level99-111 python杂项2</h1><p>重复86-98的工作</p><h1 id="level112-124-c杂项2"><a href="#level112-124-c杂项2" class="headerlink" title="level112-124 c杂项2"></a>level112-124 c杂项2</h1><p>重复86-98的工作</p><h1 id="level125-139-脚本编写"><a href="#level125-139-脚本编写" class="headerlink" title="level125-139 脚本编写"></a>level125-139 脚本编写</h1><p>均使用pwntools编写，计算依靠eval()实现，发送信号由os.kill实现</p><p>令程序的stdin,stdout都由cat来连接时，pwntools的pipe似乎不怎么好用(?)，使用os.pipe实现</p><h1 id="level140-Webserver"><a href="#level140-Webserver" class="headerlink" title="level140 Webserver"></a>level140 Webserver</h1><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>在 Linux 中有这样一个特殊文件 <code>/dev/&#123;tcp|udp&#125;/$&#123;host&#125;/$&#123;port&#125;</code>，打开这个文件，就相当于发出了一个 socket 调用，建立了一个 socket 连接，读写这个文件就相当于在该 socket 连接中传输数据。</p><p><code>/dev/&#123;tcp|udp&#125;/$&#123;host&#125;/$&#123;port&#125;</code>不是一个真实的文件，且仅存在于bash，其他的shell如sh、dash、zsh中是没有的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">exec</span> 9&lt;&gt; /dev/tcp/www.baidu.com/80</span><br>在当前 shell 中创建一个文件描述符 9，该文件描述符的输入和输出都重定向到/dev/tcp/www.baidu.com/80<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">while read -u 3 LINE;do #从fd3读取并输出<br>        echo $LINE<br>        line1=$LINE<br>        echo 1 &gt;&amp;3 #输出到指定fd<br>done<br></code></pre></td></tr></table></figure><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>直接使用 pwntools 的 remote</p><h2 id="c"><a href="#c" class="headerlink" title="c"></a>c</h2><p>c语言socket programming (TCP)</p><p><a href="https://www.geeksforgeeks.org/tcp-server-client-implementation-in-c/">https://www.geeksforgeeks.org/tcp-server-client-implementation-in-c/</a></p><p><a href="https://www.geeksforgeeks.org/socket-programming-cc/">https://www.geeksforgeeks.org/socket-programming-cc/</a></p>]]></content>
    
    
    <categories>
      
      <category>pwn learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwncollege</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
